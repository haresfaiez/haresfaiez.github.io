## Annex (Haskell/Quickcheck)
*** `unGen` from `gen`, `shriker` is ...?
After doing some inlining, we get the definition of this `unGen` function:
```haskell
-- gen :: Gen (b, a) / shrinker :: (b, a) -> [(b, a)] / f :: (b, a) -> prop, m :: QCGen -> Int -> (b, a) / initiallyGenerated :: (b, a)
unGen r n =
  let initiallyGenerated = m r1 n
  in
    case split r of
      (r1, r2) ->
        let MkGen m' = unProperty
                            $ shrinking shrinker initiallyGenerated (\x -> foldr counterexample (property (f x)) (shw x))
        in m' r2 n
```
First, we split the random number generator `r` into `r1` and `r2`.
Then, we apply the function from the function input generator with `r1` and `n`.
Then, we apply `shrinking` to create a `Property` instance.
We unwrap it and get a `Gen Prop` instance.
We use this last to compute the result.
We apply this function with `r2` and `n` to get the final result.
It takes a `shrinker` as a first argument.
This is a function that takes a value and tries to build smaller values.
For example, a shrinker for an array input tries to remove some elements for the array.
The second argument is the actual value we will test.
It's generated by `m r n` in the previously.
The third argument is the property itself.

*** `property` is ...?
We'll study how this instance is created so that we understand what unfolding it means.
After inlining calling functions, we get:
```haskell
property f =
  -- gen :: Gen (b, a) / shrinker :: (b, a) -> [(b, a)] / f :: (b, a) -> prop
  again
    $ MkProperty
      $ gen >>=
           \x -> unProperty
                   $ shrinking shrinker x (\x -> foldr counterexample (property (f x)) (shw x))
```
`again` sets `abort` to `False` in the result structure.
`MkProperty` creates a `Property` instance from a `Gen Prop` intance.
?? And we set `abort` to `False` so that we execute in the next iteration maybe.?
`Gen`?{{{
  `again` here converst a `Testable prop` to a `Property`, wihch is have `unProperty:: Gen Prop`.
  the second and third definitions means that if we a `Prop` value,
  then we'll have first a `Testable Prop`, and then a `Testable (Gen Prop)` value.
  This value is created with `property` call, and have a `unProperty` function.
  The trick to convert `prop`, not `Prop` with big `P`, value to a `Gen Prop` is in the most-first definiton,
  exactly in the `fmap`:
  ```haskell
  fmap :: Functor f => (a -> b) -> f a -> f b
  ```
  here `f` is `Gen`, `a` is `Prop`, and `b` is `Prop` to.
  `(a -> b)` is `f` above, a function that sets `abort` to `False`.
  Implementing the `fmap` is the responisiblity of the `Gen` definer.
  ```haskell
  instance Functor Gen where
    fmap f (MkGen h) =
      MkGen (\r n -> f (h r n))
  ```
  In `mapProp`, `unProperty . property` coneverts a property of `prop :: Testable` to `Gen Prop`.
  `property` converts `prop :: Testable` to `Property` (see the last definition)
  `unProperty` converts this to `Gen Prop`.

  Everything that hsould be tested should be converted first to a `Gen Prop`.
  That said, the `Prop` we get and convert to `Gen Prop`.
  This is done in the second definition above, mainly with `return . protectProp $ p`.
  `p` is the `Prop`, `protectProp` is `protectProp :: Prop -> Prop`.
  `return` indeed is `return :: Prop -> Gen Prop`,
  or technically `return :: Monad m => a -> m a`.
  The monad is `Gen`.
}}}

**** Inline `prop_cyclic` definition further:
```haskell
prop_cyclic :: Property
prop_cyclic =
  again $
    MkProperty $
    (Blind <$> cyclicList) >>= \x ->
      unProperty $
      shrinking 
        (\_ -> [])
        x
        (\y ->
          counterexample
          (show y) 
          ((\(Blind xs) -> and $ take 100 $ zipWith (==) xs (drop 2 xs))
            y)
        )
```
which means
```haskell
-- | Randomly generates a function of type @'Gen' a -> a@, which
-- you can then use to evaluate generators. Mostly useful in
-- implementing 'promote'.
delay :: Gen (Gen a -> a)
delay = MkGen (\r n g -> unGen g r n)

-- | Promotes a monadic generator to a generator of monadic values.
promote :: Monad m => m (Gen a) -> Gen (m a)
promote m = do -- m :: Rose (Gen (??Prop))
  eval <- delay -- eval :: Rose (Gen (??Prop)) -> Rose (??Prop)
  return (liftM eval m) -- eval :: (a1 -> r), m :: m a1, liftM :: (a1 -> r) -> m a1 -> m r
  -- Rose (Gen (??Prop)) -> Gen (Rose (??Prop))

-- ...

-- | Adds the given string to the counterexample if the property fails.
counterexample :: Testable prop => String -> prop -> Property
counterexample s = -- s : String
  let a = MkProperty
   . fmap (
      \(MkProp t) -> 
          MkProp (fmap (\res -> res{ testCase = s:testCase res }) t) -- functor = Rose, f :: Result -> Result
      ) -- functor = Gen, f :: Prop -> Prop, t :: Rose Result
   . unProperty
   . property
  in
    a .
    callback (PostFinalFailure Counterexample $ \st _res -> do
      s <- showCounterexample s
      putLine (terminal st) s)

-- ...

(:) :: a -> [a] -> [a]

---- ME: generates an array with period=2
cyclicList :: Gen [Int]
cyclicList = do
  rec xs <- fmap (:ys) arbitrary --- fmap (Int -> [Int]) (Gen Int) :: Gen [Int]
      ys <- fmap (:xs) arbitrary --- fmap (Int -> [Int]) (Gen Int) :: Gen [Int]
  return xs -- xs :: [Int]

cyclicList = do
  (xs, ys) <- mfix (
    \ ~(xs, ys) -> -- :: ([Int], [Int])
       do {
         xs <- fmap (:ys) arbitrary ; --- :: Gen [Int]
         ys <- fmap (:xs) arbitrary ; --- :: Gen [Int]
         return (xs, ys)
       }
    ) --- :: Gen ([Int], [Int])
  return xs
//...
mfix :: (a -> m a) -> m a
mfix :: (([Int], [Int]) -> Gen ([Int], [Int])) -> Gen ([Int], [Int])

-- ...

prop_cyclic :: Property
prop_cyclic =
  let a = (
      MkProperty
      . fmap (
            mapProp (
                \(MkProp t) -> MkProp (
                    fmap (\res -> res{ abort = False }) t -- Rose Result / functor = Rose / f :: Result -> Result
                  ) -- t :: Rose Result
              ) -- Prop -> Prop
          ) -- Gen Prop / functor = Gen / f :: Prop -> Prop / :: Sets abort to False in the Result inside. The Result is inside Rose, which is inside Prop, that is inside Gen. 
      . unProperty -- Gen Prop
      . property -- Property
    ) -- :: Sets abort to False in the Result inside, and wrap again.


    pf y = -- y :: Blind (Gen [Int])
      counterexample
        (show y) -- String
        ( (\(Blind xs) -> and $ take 100 $ zipWith (==) xs (drop 2 xs)) y ) -- Bool / y :: Blind (Gen [Int]) -> Bool / True if
      --- Property (or is it Gen Property ?)

    props y = MkRose 
      ((unProperty . property . pf) y) [ props x' | x' <- [] ] -- Gen Prop === Gen (MkProp (Rose Result)) // - \x -> [] is shrinker :: a -> [a]
     -- Rose (Gen ??Prop) === MkRose a [Rose a] | IORose (IO (Rose a))
     -- y :: Blind (Gen [Int]) -> Rose (Gen (??Prop))

    shrk x = MkProperty (
        fmap
          (MkProp . joinRose . fmap unProp) -- Prop -> Prop
          (promote
              (props x) -- ??Rose (Gen (??Result)) <<< Rose (Gen (??Prop))
            ) -- Gen Prop === (Gen (Rose (??Result))) <<< Gen (??(Rose Result)) <<< Gen (Rose (??(Rose Result))) <<< Gen (Rose (??Prop))
          -- Gen Prop / functor = Gen / f = Prop -> Prop
      ) -- Property
       

  in
    a (
      MkProperty (
        (fmap Blind cyclicList) -- Gen (Blind (Gen [Int]))
            >>= (\x -> unProperty (shrk x)) -- :: (Blind (Gen [Int])) -> Gen Prop
        -- Gen Prop
      ) -- Property
    )
```

*** why do we need `Blind`
For example here
```haskell
prop_failingTestCase :: Blind (Int -> Int -> Int -> Bool) -> Property
prop_failingTestCase (Blind p) = ioProperty $ do
  res <- quickCheckWithResult stdArgs{chatty = False} p
  let [x, y, z] = failingTestCase res
  return (not (p (read x) (read y) (read z)))
```

*** `Gen` definition
```haskell
-- | A generator for values of type @a@.
--
-- The third-party packages
-- <http://hackage.haskell.org/package/QuickCheck-GenT QuickCheck-GenT>
-- and
-- <http://hackage.haskell.org/package/quickcheck-transformer quickcheck-transformer>
-- provide monad transformer versions of @Gen@.
newtype Gen a = MkGen{
  unGen :: QCGen -> Int -> a -- ^ Run the generator on a particular seed.
                             -- If you just want to get a random value out, consider using 'generate'.
  }
//...
instance Applicative Gen where
  pure x =
    MkGen (\_ _ -> x)
  (<*>) = ap
//...
instance Monad Gen where
  return = pure

  MkGen m >>= k =
    MkGen (\r n ->
      case split r of
        (r1, r2) ->
          let MkGen m' = k (m r1 n)
          in m' r2 n
    )

  (>>) = (*>)
```

*** `localMin` definition
Here's a simplified version of the loop
```haskell
localMin :: State -> P.Result -> [Rose P.Result] -> IO (Int, Int, Int, P.Result)
localMin st res ts = do
  ts' <- tryEvaluate ts
  localMin' st res (either (\_ -> []) id ts')

localMin' :: State -> P.Result -> [Rose P.Result] -> IO (Int, Int, Int, P.Result)
localMin' st res [] = localMinFound st res
localMin' st res (t:ts) = do
  MkRose res' ts' <- protectRose (reduceRose t)
  res' <- callbackPostTest st res'
  let st' = if ok res' == Just False
              then st { numSuccessShrinks = numSuccessShrinks st + 1, numTryShrinks = 0 }
              else st { numTryShrinks = numTryShrinks st + 1, numTotTryShrinks = numTotTryShrinks st + 1 }
  localMin st' res' ts
```

*** `shrinking` definition
```haskell
shrinking shrinker x0 pf = MkProperty (
    fmap :: (Rose Prop -> Prop) -> Gen (Rose Prop) -> Gen Prop
                fmap :: (Prop -> Rose Result) -> Rose Prop -> Rose (Rose Result)
                joinRose :: Rose Rose Result -> Rose Result
    fmap (MkProp . joinRose . fmap unProp) (promote (props x0))
  )
 where
  props :: a -> Rose (Gen Prop)
  props x =
    MkRose (unProperty (property (pf x))) [ props x' | x' <- shrinker x ]
```

*** `forAll` definition helpers
```haskell
mapProp :: Testable prop => (Prop -> Prop) -> prop -> Property
mapProp f = MkProperty . fmap f . unProperty . property
//...
-- f here mustn't throw an exception (rose tree invariant).
mapRoseResult :: Testable prop => (Rose Result -> Rose Result) -> prop -> Property
mapRoseResult f = mapProp (\(MkProp t) -> MkProp (f t))
//...
mapTotalResult :: Testable prop => (Result -> Result) -> prop -> Property
mapTotalResult f = mapRoseResult (fmap f)
//...
-- | Modifies a property so that it will be tested repeatedly.
-- Opposite of 'once'.
again :: Testable prop => prop -> Property
again = mapTotalResult (\res -> res{ abort = False })
//...
instance Testable Result where
  property = MkProperty . return . MkProp . protectResults . return

instance Testable Prop where
  property p = MkProperty . return . protectProp $ p

instance Testable prop => Testable (Gen prop) where
  property mp = MkProperty $ do p <- mp; unProperty (again p)

instance Testable Property where
  property (MkProperty mp) = MkProperty (fmap protectProp mp)
```

*** exception handling??
```
-- The story for exception handling:
--
-- To avoid insanity, we have rules about which terms can throw
-- exceptions when we evaluate them:
--   * A rose tree must evaluate to WHNF without throwing an exception
--   * The 'ok' component of a Result must evaluate to Just True or
--     Just False or Nothing rather than raise an exception
--   * IORose _ must never throw an exception when executed
--
-- Both rose trees and Results may loop when we evaluate them, though,
-- so we have to be careful not to force them unnecessarily.
--
-- We also have to be careful when we use fmap or >>= in the Rose
-- monad that the function we supply is total, or else use
-- protectResults afterwards to install exception handlers. The
-- mapResult function on Properties installs an exception handler for
-- us, though.
--
-- Of course, the user is free to write "error "ha ha" :: Result" if
-- they feel like it. We have to make sure that any user-supplied Rose
-- Results or Results get wrapped in exception handlers, which we do by:
--   * Making the 'property' function install an exception handler
--     round its argument. This function always gets called in the
--     right places, because all our Property-accepting functions are
--     actually polymorphic over the Testable class so they have to
--     call 'property'.
--   * Installing an exception handler round a Result before we put it
--     in a rose tree (the only place Results can end up).
```

*** `Testable` for a `function` is ...?
```haskell
instance (Arbitrary a, Show a, Testable prop) => Testable (a -> prop) where
  property f =
    propertyForAllShrinkShow arbitrary shrink (return . show) f
  propertyForAllShrinkShow gen shr shw f =
    -- gen :: Gen b, shr :: b -> [b], f :: b -> a -> prop
    -- Idea: Generate and shrink (b, a) as a pair
    propertyForAllShrinkShow
      (liftM2 (,) gen arbitrary)
      (liftShrink2 shr shrink)
      (\(x, y) -> shw x ++ [show y])
      (uncurry f)
      --- === Testable (b, a)/propertyForAllShrinkShow

class Testable prop where
  propertyForAllShrinkShow :: Gen a -> (a -> [a]) -> (a -> [String]) -> (a -> prop) -> Property
  propertyForAllShrinkShow gen shr shw f =
    forAllShrinkBlind gen shr $ \x -> foldr counterexample (property (f x)) (shw x)


liftM2 :: (b -> a -> (b, a)) -> Gen b -> Gen a =--> Gen (b, a)
liftShrink2 :: (b -> [b]) -> (a -> [a])        =--> (b, a) -> [(b, a)] 
uncurry :: (b -> a -> prop)                    =--> (b, a) -> prop --- (b, a) === f b a



property f =
  -- gen :: Gen (b, a) / shrinker :: (b, a) -> [(b, a)] / f :: (b, a) -> prop
  again
    $ MkProperty
      $ MkGen (\r n ->
              case split r of
                (r1, r2) ->
                  let MkGen m' = unProperty
                                      $ shrinking shrinker (m r1 n) (\x -> foldr counterexample (property (f x)) (shw x))
                  in m' r2 n
            ) --- m === ungen :: QCGen -> Int -> Prop === deconstruction of (gen = MkGen Prop)
```
