// IGNORE IE8/MOZILLA_AST
# focus on happy path

* ast.js
  - call DEFNODE(type, props, methods, base) -> Constructor (Props -> Token) for each token type [1]
  - define a TreeWalker(Visit), Visit(Node: currentNode, Descend)
    has a method _visit(Node, Descend) ->
    Visit returns true/false if we should not decend/or-we-should
    Descend is defined by the node, it takes the walker down the constituants of the node
    A node may not define define Descend and thus the walker does not go farther
    it is the callback Visit passed to the constructor that calls Descend
  - define AST_*._walk (Visitor) -> calls Visitor._visit(this, fn), fn calls _walk on each component AST_x
    e.g.
    DEFNODE('....', ...
        _walk: function(visitor) {
          return visitor._visit(this, function() {
              this.value._walk(visitor); //takes the walker down
          });
        }
    )
    Visitor is an instance of TreeWalker(fn)

* parse.js
  - has two main fns: tokenizer and parse [2]
  - tokenizer
    - has a structure S
        var S = {
        text            : $TEXT,
        filename        : filename,
        pos             : 0,
        tokpos          : 0,
        line            : 1,
        tokline         : 0,
        col             : 0,
        tokcol          : 0,
        newline_before  : false,
        regex_allowed   : false,
        comments_before : [],
        directives      : {},
        directive_stack : []
    }
    - all fns work on S
    - token() creates an AST_Token
    - returns a fn next_token() which sees(peeks?) the next chars and returns the result of either
      read_regexp ; token ; read_string ; handle_dot ; tok ; read_num ; token ; read_operator ; read_wordy
    ?? node vs ast_scope

  - parse
    - has a structure S
        var S = {
        input         : (typeof $TEXT == "string"
                         ? tokenizer($TEXT, options.filename,
                                     options.html5_comments, options.shebang)
                         : $TEXT),
        token         : null,
        prev          : null,
        peeked        : null,
        in_function   : 0,
        in_directives : true,
        in_loop       : 0,
        labels        : []
    }
    - all fns works on S
    - builds body[AST_*] as a collection of AST_* // while (!is("eof")) body.push(statement(true))
      then - toplevel = new AST_Toplevel({ start: start, body: body, end: end }); // if options.toplevel is false
           - otherwise // toplevel.body = toplevel.body.concat(body); toplevel.end = end;
    - S.input() computes the next token
    - next has `S.token = S.input()`
    - creates AST_* instances
    - usually, every AST_x type has a x_ fn
    - wraps all in an AST_Toplevel object
    - return an ast toplevel
    - helpers fns follow a pattern: start = S.token; // extract body (S.taken.value, ...); next(); return new AST_x
    - moves to the next token using next()
      next() sets S.prev/S.token/S.peeked -> null/S.in_directives/return S.token
    - handle_regex is called at the beginning of [BREAKPOINT]
      statement() -> , expression() -> , maybe_unary() ->
      it puts an RegExp? the current token S.token
    - when options.expression is truthy, call handle_regex then returns  expression()
    - expression(Comma?) -> // DESIGN PROBLEM, fns used once pollutes the global scope
      maybe_unary() and make_unary() are used only in expr_op()
      expr_op() is used only in maybe_conditional()
      maybe_conditional() is used only in maybe_assign()
      maybe_assign() is used only in expression(),
      return the first expression (until comma) or parses the next() tokens until it finds a non-comma after one
      returns either an AST_Sequence of maybe_assign or an expression of maybe_assign
    - statement() [BREAKPOINT]
    - maybe_xyz fns [BREAKPOINT]

* transform.js (`transform`)
  - defines TreeTransformer(Before, After) -> { TreeWalker.call(this) }
    TreeTransformer.prototype = new TreeWalker
    uses TreeWalker push/pop methods
    uses its own before/after
    transform(TreeWalker, in_list) -> Before() || (After() || this)
     {
     - calls before
     - if undefined, calls descend and after
     }
  - defines a method `transform` on some AST_x element types [4]
  - replaces each element component with the result of `transform` on that component (`descend()`)
  - returns the transformed element
  - passes on treeWalker in each `transform` call
  - AST_x::transform::descend is similar to AST_x::_walk
    this.[subComponent]._walk -> self.[subComponent] = self.[subComponent].transform(tw)

* propmangle.js
  - defines fn reserve_quoted_keys(AST, Reserved)
    adds properties keys accessed with obj['key'] and obj.key(where quote is truthy)
  - mangles object properties (a,  in { a: 1 }, setter/getter, foo.a, foo["a"], Object.defineProperty("a", ...)...)
    (mangle: rename variables and fns to shorter names (usually one-letter names))
    AST_Call
    AST_Conditional
    AST_Dot
    AST_ObjectKeyVal
    AST_ObjectProperty
    AST_Sequence
    AST_String
    AST_Sub
    use add/addStrings -> mangle/mangleStrings, have the same map as walk -> transform
  - fns use
    options:
    names_to_mangle: names of properties that can be mangled (all except unmangleable, reserved, and numbers)
    unmangleable: names of properties that should not be mangled (does not match existing options.regex, reserved, isNotInCache-and-isNotInNamesToMangle)
    A property name can be in both, names_to_mangle and unmangleable ? precedence?
  - defines a fn mangle_properties(Ast, Options) -> Transformed_Ast which
    step 1: find candidates to mangle
      - uses ast.walk
      - builds names_to_mangle and unmangleable
    step 2: transform the tree, renaming properties
      - uses ast.transform
      - does not transfrom the ast, it just sets the key/property/... to mangled version
      - mangled version is base54(++cname), cname is a counter init at -1

  - the output varies when options.debug is enabled
     // debug mode: use a prefix and suffix to preserve readability, e.g. o.foo -> o._$foo$NNN_
     if debug is enabled mangle(Name) -> "_$" + Name + "$" + debug_suffix + "_";
  - the output varies when options.cache is falsey
  - minify(AST|File, Options)

* minify.js
  - options: compress, mangle, mangle_props, enclose, wrap, cache
  - defines a fn minify(files, options) -> result
    result = {
       ast: toplevel
       code: stream.get()
       map: //source map
       timings: {
           start
           parse
           rename
           compress // compress toplevel
           scope // toplevel.figure_out_scope(options.mangle)
           mangle // toplevel.compute_char_frequency(options.mangle and toplevel.mangle_names(options.mangle)
           properties //toplevel = mangle_properties
           output // fill result.code
           end
           total
       }
       warnings
     }

  - pseudocode:
    function minify(files, options) {
      // init cache: options.mangle.cache|properties.cache -> cache is a dictionary

      // parse: options.parse.filename=lastfile, options.parse.toplevel = parse(file, options.parse)
      // concatenates ast of all files
      //             source_maps[name] = source_map_content;??
      for (var name in files) {
        options.parse.filename = name;
        options.parse.toplevel = parse(files[name], options.parse);
        // put each file source map in source_maps[name]
      }

      // wrap the result in fn(options.before:) {code} (options.after:)
      // enclose? toplevel = toplevel.enclose(options.enclose) //files[toplevel.start.file] = replace(.*-1, '')
      // wrap? toplevel = toplevel.wrap(options.wrap) //files[toplevel.start.file] = replace(.*-1, '')

      //if options.rename = options.rename || (options.compress && options.mangle);
      toplevel.figure_out_scope(options.mangle);
      toplevel.expand_names(options.mangle);

      if (options.compress) toplevel = new Compressor(options.compress).compress(toplevel);

      // if (options.mangle)
      toplevel.figure_out_scope(options.mangle);
      toplevel.compute_char_frequency(options.mangle);
      toplevel.mangle_names(options.mangle);
      toplevel = mangle_properties(toplevel, options.mangle.properties);

      result.ast = toplevel;

      // if we need output.code
      // if (options.sourceMap)
      if (options.sourceMap.includeSources) {
        foreach file->name -> options.output.source_map.get().setSourceContent(name, files[name]);
      } else {
        options.output.source_map.get()._sourcesContents = null;
      }
      // result.code = OutputStream(options.output) -> toplevel.print -> get

      //if (options.sourceMap)
      result.map = options.output.source_map.toString();
      // if url: inline|url
      result.code = result.code.replace(/\n\/\/# sourceMappingURL=\S+\s*$/, "");
      // add to result.code a //# sourceMappingUrl=data:app....|url

      // update options.nameCache.vals|props from options.mangle.cache|properties.cache

      result.warnings = warnings;
      return result;
    }

* sourcemap.js
  - a small wrapper around fitzgen's source-map library (https://github.com/mozilla/source-map)
  - exports a function (Options) -> { add, get, toString }
  - source map creates a generator and adds to it sources from source-maps in the options in options.orig
    options.orig = {source-name: source-map, source-name-2: { sources: [source-file, source-file2, ...] } }
  - puts each source-map in maps[source]
  - generator->addSource(source-file), maps[source-name] = source-map
  - get returns the generator and toString -> stringify(generator.toString())
  - uses source, orig_line, orig_col, name from the existing maps[source] and
    "Add a single mapping from original source line and column to the generated source's line and column for this source map being created"

* scope.js
  - AST_Scope: [INCOMPLETE: where each is set]
          variables: "[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
        functions: "[Object/S] like `variables`, but only lists function declarations",
        uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
        uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
        parent_scope: "[AST_Scope?/S] link to the parent scope",
        enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
        cname: "[integer/S] current index for mangling variables (used internally by the mangler)",
    - defines SymbolDef, a variable or a global reference
  - attaches to AST_* functions useful for scope-ish operations [3]
  - AST_TopLevelfigure_out_scope: (walks the TopLevel scope through 3 passes using three TreeWalker s)
     * AST_Scope is the "> Base class for all statements introducing a lexical scope"
       scope
        <toplevel
        <lambda
          <accessor
          <function
       AST_Symbol:
         AST_Symbol: "Base class for all symbols",
         AST_SymbolAccessor: "The name of a property accessor (setter/getter function)"
         AST_SymbolDeclaration: "A declaration symbol (symbol in var, function name or argument, symbol in catch)",
         AST_SymbolVar : "Symbol defining a variable",
         AST_SymbolFunarg: "Symbol naming a function argument",
         AST_SymbolDefun: "Symbol defining a function",
         AST_SymbolLambda: "Symbol naming a function expression",
         AST_SymbolCatch: "Symbol naming the exception in catch",

        AST_Symbol
          < AST_SymbolAccessor
          < AST_Label
          < AST_SymbolRef
          < AST_LabelRef
          < AST_This
          < AST_SymbolDeclaration
            < AST_SymbolDefun
            < AST_SymbolLambda
            < AST_SymbolCatch
            < AST_SymbolVar
              < AST_SymbolFunarg
     * "// pass 1: setup scope chaining and handle definitions"
       walks the top level using a TreeWalker that
     * "// pass 2: find back references and eval"
     * "// pass 3: fix up any scoping issue with IE8" [IGNORED]
     * used in:
       ** Compressor::compress()
  - fns doc
  AST_Toplevel.DEFMETHOD("figure_out_scope", function(options) {
options = defaults(options, { cache: null, ie8: false });
// pass 1: setup scope chaining and handle definitions
scope // upper scope
defun // upper function definition

// WALKER
AST_Catch -> // calls init_scope_vars
AST_Scope -> // calls init_scope_vars
AST_Symbol -> // sets the scope to the scope of parent

AST_SymbolDefun -> // defines a function in the parent function scope (defun.parent_scope )
AST_SymbolLambda -> // defines a function in the current function scope (defun)
AST_SymbolVar -> // defines a variable in the current function scope(defun)
AST_SymbolCatch -> // scope.def_variable(node).defun = defun;

// pass 2: find back references and eval
self.globals = new Dictionary(); // init TopLevel.globals

AST_LoopControl // (break or continue): add current node to its definition->references
AST_SymbolRef // reference to some symbol: set thedef(symbol definiotn) to scope.find_variable || def_global

// ensure mangling works if catch reuses a scope variable
 AST_SymbolCatch // Symbol naming the exception in catch:
// find scope where the symbol is first defined and put it in each sub-scope.enclosed
  // loop currentScope -> scopeWhereNodeDefined(=def) and forEach s->push(s.enclosed, def)
  // s.enclosed: ">a list of all symbol definitions that are accessed from this scope or any subscopes"
});

AST_Toplevel.DEFMETHOD("def_global", // form node.name return a global SymbolDef if exists or set one
    // vars associated with scope in AST_Scope
variables // map name to AST_SymbolVar (variables defined in this scope; includes functions)
functions // map name to AST_SymbolDefun (functions defined in this scope)
uses_with // will be set to true if this or some nested scope uses the `with` statement
uses_eval // will be set to true if this or nested scope uses the global `eval`
parent_scope // the parent scope
enclosed // a list of variables from this or outer scope(s) that are referenced from this or inner scopes
cname // the current index for mangling functions/variables

AST_Scope.DEFMETHOD("init_scope_vars", // init scope vars

AST_Lambda.DEFMETHOD("init_scope_vars", // init scope vars, and define variable "arguments" as AST_SymbolFunarg

AST_Scope.DEFMETHOD("find_variable", function(name) // find var by name in current or parent scope

AST_Scope.DEFMETHOD("def_variable", // mutate the var if exist or
                    // (create a new SymbolDef and set this.variables)

AST_Scope.DEFMETHOD("def_function", function(symbol, init) // calls def_variable and set this.functions

  - [INCOMPLETE] remaining fns doc

* compress.js
  - defines a Compressor(Options) which inherits TreeTransformer
  - the constructor relies on methods defined below
  - the constructor init TreeTransformer then goes over some options
    * global_defs, parse global definitions when needed, assume keys starting with "@" not parsed and
        for each key global_defs[key.slice(1)] = parse(global_defs[key], { expression: true
    * keep_fargs, define fn drop_fargs = f(Strict?
        False -> ret True|False depending on keep_fargs
        True  -> ret fn(AST_Lambda, Parent) -> True if its inline call or
    [INCOMPLETE]
  - defines fns on the compressor prototype, the interesting ones are
    * [INCOMPLETE]
  - this is the kind of files the bearded wizard warned you about
  - defines a method "optimize" on [5]
  - defines a method "reduce_vars" on [6]
  - defines "methods to evaluate a constant expression"
    * defines evaluate and is_constant on AST_Node
      evaluate:
        > If the node has been successfully reduced to a constant,
        > then its value is returned; otherwise the element itself
        > is returned.
        > They can be distinguished as constant value is never a
        > descendant of AST_Node.
    * defines a method "_eval" on [7]
  - defines a method "drop_side_effect_free" on [8] that
    > remove side-effect-free parts which only affects return value
  - defines a method "drop_unused" on AST_Scope
  - defines other methods on different AST_x types [9]
  - [INCOMPLETE: what each method does]


* output.js
  - defines a fn OutputStream(Options) -> Stream
  Stream {
    get
    toString
    indent
    indentation
    current_width
    should_break
    has_parens
    newline
    print
    space
    comma
    colon
    last
    semicolon
    force_semicolon
    to_utf8
    print_name
    print_string
    encode_string
    next_indent
    with_indent
    with_block
    with_parens
    with_square
    add_mapping
    option
    prepend_comments
    append_comments
    line
    col
    pos
    push_node
    pop_node
    parent
  }
  - Stream works on stack: push_node, parent[of last pushed node]
  - define code generators
  - things going together
    mapping
    current position
    OUTPUT construction
  - OutputStream decisions are based on vars that hold state
    last //last printed string?
    OUTPUT
    has_parens
    current_pos
    current_line
    current_col
    line_end // length of current line
    line_fixed
    new_line_insert
    might_need_semicolon //whether the current? need a semicolon
    indentation
    mapping_token
    mapping_name
  - fn
  function OutputStream(options) {
  // sets a comment filter (Options) -> CommentFilter, CommentFilter(Comment) -> Boolean(true==keep)
  // Options = False | Regexp | Function | "Some" | Otherwise True

    var to_utf8 = // fn

    function make_string(str, quote) {
      // add backslash to each character matching /[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/
      // case "\0": return /[0-9]/.test(str.charAt(i+1)) ? "\\x00" : "\\0"; ?
      str = to_utf8(str);
      // check options.quote_style and
      // put string between single quotes
      // put string between double quotes
    }
    function encode_string(str, quote) // ~=make_string(str, quote);
    function make_name(name) // name -> to_utf8
    function make_indent(back) // spaceCount(Options, indentation, back)

    /* -----[ beautification/minification ]----- */
    var last = ""; // changed at the end of print()
    var mapping_token, mapping_name, mappings = options.source_map && [];

    // if options.source_map
    var adjust_mappings = // (Line, Col) add line, col (mapping.line +=) to each options.source_map
    var flush_mappings = // put mappings into options.source_map and reset mappings

    function insert_newlines(count) // adds count new lines starting from the last index of \n
    // and adjust the mappings (with count, afterLastIndex.length - current_col)
    // and adjust current_line, current_pos, current_col
    // and set OUTPUT = beforeLastI + count * \s + afterLastI

    var fix_line = //options.max_line_len, line_fixed
                 -> Exceed && (Warn | (insert_line, line_fixed=true, flush_mapping))

    // vars influentcig print (stF: set it to false)
    // #ch[0]
    // need_new_line_indented -> stF && print \n && indent()
    // need_space -> stF && space() when not \s ; } )
    // newline_insert = -1;
    // # last[last.length-1]
    // might_need_semicolon -> stF && [prev-is-: && ch-is-}] || [(!ch || (!*;* && !*}*)) && !prev;]
    //                         if ch in "( [ + * / - , ." -> outpout+=;
    //                            or fix_line() && output+=\n && current_col = 0
    //                               if (/^\s+$/.test(str)) reset the semicolon flag, since we didn't print one
    //                               now and might still have to later might_need_semicolon = true;
    //                         && current_col|pos ++
    //                             && if (!options.beautify) might_need_space = false;
    // might_need_space -> stF && output+=' ' current_col|pos++ when
    //                ((is_identifier_char(prev) && (is_identifier_char(ch) || ch == "\\"))
    //                || (ch == "/" && ch == prev) || ((ch == "+" || ch == "-") && ch == last))
    // mapping_token -> stF && add mapping (mapping_token|name, current_line|col) && line_fixed && flush_mappings
    function print(str) {
        OUTPUT += str;
        has_parens = str[str.length - 1] == "(";
        current_pos += str.length;
        var a = str.split(/\r?\n/), n = a.length - 1;
        current_line += n;
        current_col += a[0].length;
        if (n > 0) {
            fix_line();
            current_col = a[n].length;
        }
        last = str;
    }


    var space //options.beautify && print ' ' || might_need_space = true
    var indent //options.beautify && print indent/half

    var newline = options.beautify ? function() {
    var semicolon// options.beautify && print || might_need_semicolon = true

    function force_semicolon() { //#exposed
    function next_indent() { //#exposed

    var with_indent = options.beautify ? function(col, cont) { //#exposed

    function with_block(cont) {//#exposed print {\n[with_indent(next_indent]} -> put in {...}

    function with_parens(cont) {//#SAME (\n?[cont]\n?)-> put in (...)

    function with_square(cont) {//#SAME as(..) -> put in [...]

    function comma() {// print \n?,\n?' '
    function colon() {// print :' '

    var add_mapping = mappings ? function(token, name) {//#exposed

    function get() { //#exposed return OUTPUT

    function prepend_comments(node) {//# exposed

    function append_comments(node, tail) {//# exposed

}

/* -----[ code generators ]----- */
    /* -----[ source map generators ]----- */

    function DEFMAP(nodetype, generator) { // def method add_source_map -> output.add_mapping(this.start, Nothing|(this.key.name | this.key))
    DEFMAP([
        AST_Array,
        AST_BlockStatement,
        AST_Catch,
        AST_Constant,
        AST_Debugger,
        AST_Definitions,
        AST_Directive,
        AST_Finally,
        AST_Jump,
        AST_Lambda,
        AST_New,
        AST_Object,
        AST_StatementWithBody,
        AST_Symbol,
        AST_Switch,
        AST_SwitchBranch,
        AST_Try,
    DEFMAP([
        AST_ObjectGetter,
        AST_ObjectSetter,
     ], function(output) {
        output.add_mapping(this.start, this.key.name);
    });
    DEFMAP([ AST_ObjectProperty ], function(output) {
        output.add_mapping(this.start, this.key);
    });

    /* -----[ utils ]----- */

    AST_Node.DEFMETHOD("print", function(stream, force_parens) {
        stream.push_node(self);
        stream.prepend_comments(self);
        self.add_source_map(stream);
        generator(self, stream);
        stream.append_comments(self);
        stream.pop_node();
    });
    AST_Node.DEFMETHOD("_print", AST_Node.prototype.print);
    AST_Node.DEFMETHOD("print_to_string", function(options) {
        var s = OutputStream(options);
        this.print(s);
        return s.get();
    });

    /* -----[ PARENTHESES ]----- */
    function PARENS(nodetype, func) -> define needs_parens
    // call PARENS on:     AST_Node    AST_Function
    // AST_Object    AST_Unary    AST_Sequence    AST_Binary    AST_PropAccess    AST_Call
    //    AST_New    AST_Number    AST_Assign    AST_Conditional


    /* -----[ statements ]----- */
    AST_StatementWithBody.DEFMETHOD("_do_print_body", function(output) { //make_block(this.body, output) if output.option.braces | this.body.print(output)

    /* -----[ functions ]----- */
    AST_Lambda.DEFMETHOD("_do_print", function(output, nokeyword) { //output.print|output.space

    /* -----[ PRINTERS ]----- */

    function DEFPRINT(nodetype, generator) nodetype.DEFMETHOD("_codegen", generator)
    DEFPRINT(AST_Directive, function(self, output)
    DEFPRINT(AST_Debugger, function(self, output) {
    DEFPRINT(AST_Statement, function(self, output) {

    // fn at 1 pattern: calls to output.print|print_string/output.space/output.with_parent/output.semicolon and self.*.print(output)
    DEFPRINT(AST_Toplevel, function(self, output) {
    DEFPRINT(AST_LabeledStatement, function(self, output)
    DEFPRINT(AST_SimpleStatement, function(self, output) {
    DEFPRINT(AST_EmptyStatement, function(self, output)
    DEFPRINT(AST_BlockStatement, function(self, output) {
    DEFPRINT(AST_Do, function(self, output) {
    DEFPRINT(AST_While, function(self, output) {
    DEFPRINT(AST_For, function(self, output) {
    DEFPRINT(AST_ForIn, function(self, output) {
    DEFPRINT(AST_With, function(self, output) {
    DEFPRINT(AST_Lambda, function(self, output) {
    /* -----[ jumps ]----- */
    DEFPRINT(AST_Return, function(self, output) {
    DEFPRINT(AST_Throw, function(self, output) {
    DEFPRINT(AST_Break, function(self, output) {
    DEFPRINT(AST_Continue, function(self, output) {

    /* -----[ if ]----- */
    DEFPRINT(AST_If, function(self, output) {
    /* -----[ switch ]----- */
    DEFPRINT(AST_Switch, function(self, output) {
    AST_SwitchBranch.DEFMETHOD("_do_print_body", function(output) {
    DEFPRINT(AST_Default, function(self, output) {
    DEFPRINT(AST_Case, function(self, output) {
    /* -----[ exceptions ]----- */
    DEFPRINT(AST_Try, function(self, output) {
    DEFPRINT(AST_Catch, function(self, output) );
    DEFPRINT(AST_Finally, function(self, output) );
    DEFPRINT(AST_Var, function(self, output) );
    DEFPRINT(AST_VarDef, function(self, output) );

    /* -----[ other expressions ]----- */
    DEFPRINT(AST_Call, function(self, output) {
    DEFPRINT(AST_New, function(self, output) {
    DEFPRINT(AST_Sequence, function(self, output) {
    DEFPRINT(AST_Dot, function(self, output) {
    DEFPRINT(AST_Sub, function(self, output) {
    DEFPRINT(AST_UnaryPrefix, function(self, output) {
    DEFPRINT(AST_UnaryPostfix, function(self, output) {
    DEFPRINT(AST_Binary, function(self, output) {
    DEFPRINT(AST_Conditional, function(self, output) {

    /* -----[ literals ]----- */
    DEFPRINT(AST_Array, function(self, output) {
    DEFPRINT(AST_Object, function(self, output) {
    DEFPRINT(AST_ObjectKeyVal, function(self, output) {
    DEFPRINT(AST_ObjectSetter, function(self, output) {
    DEFPRINT(AST_ObjectGetter, function(self, output) {
    DEFPRINT(AST_Symbol, function(self, output) {
    DEFPRINT(AST_Hole, noop);
    DEFPRINT(AST_This, function(self, output) {
    DEFPRINT(AST_Constant, function(self, output) {
    DEFPRINT(AST_String, function(self, output) {
    DEFPRINT(AST_Number, function(self, output) {

    DEFPRINT(AST_RegExp, function(self, output) {




- Lessons learned on reading code
  - notice a pattern:
    select code/mapping, move it to a file in /tmp, view it otherwise/filter noise out, throw it away
  - map the list of AST_x definitions to a list of entries
    name: vars : ... : parent
    then use that to find inheritence chaines, query-replace-regexp: :.*: -> <
  - Tmux/Emacs/Git-using-cmd are the best
    navigation, buffers, text-manipulation, highlights, scriptiing
    program the exploration environment as well as
    emacs tools occur, grep mode
    when you copy/paste from code, Emacs keeps the colors
    insert-file-literally and copy rings
    different states of the same file opened together in different Emacs instances
    and same modified file opened at different positions inside different buffers in the same
    Emacs instance
  - you will see that in a file defining function, there is an other dimension/pattern, filter
  the file based on that. e.g. in compress.js Uglify defines methods on node types, but the definition
  has patterns there is a def and then def(AST_nodes) (essence) and then helper methods (glue)
  remove the glue and focus on the essence
  to get a better view, you may use cmds such as `grep -i 'def(\|defmethod(' compress.js > /tmp/other_defs`
  then work on the tmp file
  - start by removing helper fns to see the API
  - use behavior as an anchor to navigate structure, if you don't know where a fn is used or how
    it contributes to the result, don't spend too much on it
  - don't assume you know what the fn does from the name
  - as you read a conditional, remove what you integrate into your mental model
    if you have if(x) { y } else if(z) { w } else { b }, remove the first condition or put a comment
    in your language
  - create your language
  - for each fn, there is an essence and a glue, focus on the essence
  - delete edge cases and error handling
  - think about inline first
  - when the file is large, open it different buffer for better visualization
  - move the file to /tmp and keep only kep lines (lines having key decisions)
  - find where something is used
  - inline short functions/decompress code
  - get out of the syntax, invent your language
  - rearrange lines of code and definitons
  - do not try to hold too much in your head
  - use tools to simplify what you learn
  - importance of preparation; take time and prepare a holistic view

mozilla-ast.js

[1]:
AST_Token : Token : type value line col pos endline endcol endpos nlb comments_before comments_after file raw : - :  null
AST_Node : Node : start end :
AST_Debugger : Debugger :  null : - :  AST_Statement
AST_Directive : Directive : value quote : - :  AST_Statement
AST_SimpleStatement : SimpleStatement : body : - :  AST_Statement
AST_BlockStatement : BlockStatement :  null : - :  AST_Block
AST_EmptyStatement : EmptyStatement :  null : - :  AST_Statement
AST_StatementWithBody : StatementWithBody : body : - :  AST_Statement
AST_LabeledStatement : LabeledStatement : label : - :  AST_StatementWithBody
AST_IterationStatement : IterationStatement :  null : - :  AST_StatementWithBody
AST_DWLoop : DWLoop : condition : - :  AST_IterationStatement
AST_Do : Do :  null : - :  AST_DWLoop
AST_While : While :  null : - :  AST_DWLoop
AST_For : For : init condition step : - :  AST_IterationStatement
AST_ForIn : ForIn : init object : - :  AST_IterationStatement
AST_With : With : expression : - :  AST_Block
AST_Toplevel : Toplevel : globals : - :  AST_Scope
AST_Lambda : Lambda : name argnames uses_arguments length_read : - :  AST_Scope
AST_Accessor : Accessor :  null : - :  AST_Lambda
AST_Function : Function : inlined : - :  AST_Lambda
AST_Defun : Defun : inlined : - :  AST_Statement
AST_Exit : Exit : value : - :  AST_Jump
AST_Return : Return :  null : - :  AST_Exit
AST_Throw : Throw :  null : - :  AST_Exit
AST_LoopControl : LoopControl : label : - :  AST_Jump
AST_Break : Break :  null : - :  AST_LoopControl
AST_Continue : Continue :  null : - :  AST_Block
AST_SwitchBranch : SwitchBranch :  null : - :  AST_Block
AST_Default : Default :  null : - :  AST_SwitchBranch
AST_Case : Case : expression : - :  AST_Block
AST_Catch : Catch : argname : - :  AST_Block
AST_Finally : Finally :  null : - :  AST_Statement
AST_Var : Var :  null : - :  AST_Definitions
AST_VarDef : VarDef : name value :
AST_New : New :  null : - :  AST_Call
AST_Sequence : Sequence : expressions :
AST_PropAccess : PropAccess : expression property :
AST_Dot : Dot :  null : - :  AST_PropAccess
AST_Sub : Sub :  null : - :  AST_PropAccess
AST_Unary : Unary : operator expression :
AST_UnaryPrefix : UnaryPrefix :  null : - :  AST_Unary
AST_UnaryPostfix : UnaryPostfix :  null : - :  AST_Unary
AST_Binary : Binary : operator left right :
AST_Conditional : Conditional : condition consequent alternative :
AST_Assign : Assign :  null :
AST_Object : Object : properties :
AST_ObjectProperty : ObjectProperty : key value :
AST_ObjectKeyVal : ObjectKeyVal : quote : - :  AST_ObjectProperty
AST_ObjectSetter : ObjectSetter :  null : - :  AST_ObjectProperty
AST_ObjectGetter : ObjectGetter :  null : - :  AST_ObjectProperty
AST_Symbol : Symbol : scope name thedef :
AST_SymbolAccessor : SymbolAccessor :  null : - :  AST_Symbol
AST_SymbolDeclaration : SymbolDeclaration : init : - :  AST_Symbol
AST_SymbolVar : SymbolVar :  null : - :  AST_SymbolDeclaration
AST_SymbolFunarg : SymbolFunarg :  null : - :  AST_SymbolVar
AST_SymbolDefun : SymbolDefun :  null : - :  AST_SymbolDeclaration
AST_SymbolLambda : SymbolLambda :  null : - :  AST_SymbolDeclaration
AST_SymbolCatch : SymbolCatch :  null : - :  AST_SymbolDeclaration
AST_Label : Label : references : - :  AST_Symbol
AST_SymbolRef : SymbolRef : fixed : - :  AST_Symbol
AST_LabelRef : LabelRef :  null : - :  AST_Symbol
AST_This : This :  null : - :  AST_Symbol
AST_Constant : Constant :  null :
AST_String : String : value quote : - :  AST_Constant
AST_Number : Number : value literal : - :  AST_Constant
AST_RegExp : RegExp : value : - :  AST_Constant
AST_Atom : Atom :  null : - :  AST_Constant
AST_Null : Null :  null : - :  AST_Atom
AST_NaN : NaN :  null : - :  AST_Atom
AST_Undefined : Undefined :  null : - :  AST_Atom
AST_Hole : Hole :  null : - :  AST_Atom
AST_Infinity : Infinity :  null : - :  AST_Atom
AST_Boolean : Boolean :  null : - :  AST_Atom
AST_False : False :  null : - :  AST_Boolean
AST_True : True :  null :

[2]:
is_letter(code)
is_surrogate_pair_head(code)
is_surrogate_pair_tail(code)
is_digit(code)
is_alphanumeric_char(code)
is_unicode_digit(code)
is_unicode_combining_mark(ch)
is_unicode_connector_punctuation(ch)
is_identifier_start(code)
is_identifier_char(ch)
is_identifier_string(str)
parse_js_number(num)
JS_Parse_Error(message, filename, line, col, pos)
js_error(message, filename, line, col, pos)
is_token(token, type, val)

tokenizer($TEXT, filename, html5_comments, shebang)
    peek()
    next(signal_eof, in_string)
    forward(i)
    looking_at(str)
    find_eol()
    find(what, signal_eof)
    start_token()
    token(type, value, is_comment)
    skip_whitespace()
    read_while(pred)
    parse_error(err)
    read_num(prefix)
    read_escaped_char(in_string)
    read_octal_escape_sequence(ch)
    hex_bytes(n)
    skip_line_comment(type)
    read_name()
    read_operator(prefix)
        grow(op)
    handle_slash()
    handle_dot()
    read_word()
    with_eof_error(eof_error, cont)
    next_token(force_regexp)

parse($TEXT, options)
    is(type, value)
    peek()
    next()
    prev()
    croak(msg, line, col, pos)
    token_error(token, msg)
    token_to_string(type, value)
    unexpected(token)
    expect_token(type, val)
    expect(punc)
    has_newline_before(token)
    can_insert_semicolon()
    semicolon(optional)
    parenthesised()
    embed_tokens(parser)
    handle_regexp()
    labeled_statement()
    simple_statement(tmp)
    break_cont(type)
    if_()
    for_()
    regular_for(init)
    for_in(init)
    block_(strict_defun)
    switch_body_()
    try_()
    as_atom_node()
    expr_list(closing, allow_trailing_comma, allow_empty)
    as_property_name()
    as_name()
    _make_symbol(type)
    strict_verify_symbol(sym)
    as_symbol(type, noerror)
    mark_pure(call)
    make_unary(ctor, token, expr)
    expr_ops(no_in)
    is_assignable(expr)
    in_loop(cont)

[3]:
AST_Toplevel : figure_out_scope
AST_Toplevel : def_global
AST_Scope : init_scope_vars
AST_Lambda : init_scope_vars
AST_Symbol : mark_enclosed
AST_Symbol : reference
AST_Scope : find_variable
AST_Scope : def_function
AST_Scope : def_variable
AST_Lambda : resolve
AST_Scope : resolve
AST_Toplevel : resolve
AST_Symbol : unmangleable
AST_Label : unmangleable
AST_Symbol : unreferenced
AST_Symbol : definition
AST_Symbol : global
AST_Toplevel : mangle_names
AST_Toplevel : find_colliding_names
AST_Toplevel : expand_names
AST_Node : tail_node
AST_Sequence : tail_node
AST_Toplevel : compute_char_frequency


[4]:
AST_Node
AST_LabeledStatement
AST_SimpleStatement
AST_Block
AST_Do
AST_While
AST_For
AST_ForIn
AST_With
AST_Exit
AST_LoopControl
AST_If
AST_Switch
AST_Case
AST_Try
AST_Catch
AST_Definitions
AST_VarDef
AST_Lambda
AST_Call
AST_Sequence
AST_Dot
AST_Sub
AST_Unary
AST_Binary
AST_Conditional
AST_Array
AST_Object
AST_ObjectProperty

[5]:
AST_Node
AST_Directive
AST_Debugger
AST_LabeledStatement
AST_Block
AST_BlockStatement
AST_Lambda
AST_SimpleStatement
AST_While
AST_Do
AST_For
AST_If
AST_Switch
AST_Try
AST_Definitions
AST_Call
AST_New
AST_Sequence
AST_UnaryPostfix
AST_UnaryPrefix
AST_Binary
AST_SymbolRef
AST_Undefined
AST_Infinity
AST_NaN
AST_Assign
AST_Conditional
AST_Boolean
AST_Sub
AST_Dot
AST_Return

[6]:
AST_Node
AST_Accessor
AST_Assign
AST_Binary
AST_Call
AST_Case
AST_Conditional
AST_Default
AST_Defun
AST_Do
AST_For
AST_ForIn
AST_Function
AST_If
AST_LabeledStatement
AST_SymbolCatch
AST_SymbolRef
AST_Toplevel
AST_Try
AST_Unary
AST_VarDef
AST_While

[7]:
AST_Statement
AST_Lambda
AST_Node
AST_Constant
AST_Function
AST_Array
AST_Object
AST_UnaryPrefix
AST_Binary
AST_Conditional
AST_SymbolRef
AST_PropAccess
AST_Call
AST_New

[8]:
AST_Node
AST_Accessor
AST_Array
AST_Assign
AST_Binary
AST_Call
AST_Conditional
AST_Constant
AST_Dot
AST_Function
AST_Object
AST_ObjectProperty
AST_Sequence
AST_Sub
AST_SymbolRef
AST_This
AST_Unary

[9]:
AST_Node.DEFMETHOD("equivalent_to"
AST_Scope.DEFMETHOD("process_expression"
AST_Toplevel.DEFMETHOD("reset_opt_flags"
AST_Symbol.DEFMETHOD("fixed_value"
AST_SymbolRef.DEFMETHOD("is_immutable"
AST_SymbolRef.DEFMETHOD("is_declared"

  def(AST_Node, return_false);
  def(AST_Array, return_true);
  def(AST_Assign
  def(AST_Lambda, return_true);
  def(AST_Object, return_true);
  def(AST_RegExp, return_true);
  def(AST_Sequence
  def(AST_SymbolRef
  node.DEFMETHOD("is_truthy", func);

  AST_Node.DEFMETHOD("may_throw_on_access"

  def(AST_Node, is_strict);
  def(AST_Array, return_false);
  def(AST_Assign
  def(AST_Binary
  def(AST_Conditional
  def(AST_Constant, return_false);
  def(AST_Dot
  def(AST_Lambda, return_false);
  def(AST_Null, return_true);
  def(AST_Object
  def(AST_Sequence
  def(AST_SymbolRef
  def(AST_UnaryPrefix
  def(AST_UnaryPostfix, return_false);
  def(AST_Undefined, return_true);
  node.DEFMETHOD("_dot_throw", func);

  def(AST_Node, return_false);
  def(AST_Array, return_true);
  def(AST_Assign
  def(AST_Binary
  def(AST_Conditional
  def(AST_Constant, return_true);
  def(AST_Lambda, return_true);
  def(AST_Object, return_true);
  def(AST_Sequence
  def(AST_SymbolRef
  def(AST_UnaryPrefix
  def(AST_UnaryPostfix, return_true);
  def(AST_Undefined, return_false);
  node.DEFMETHOD("is_defined", func);

  def(AST_Node, return_false);
  def(AST_Assign
  def(AST_Binary
  def(AST_Boolean, return_true);
  def(AST_Call
  def(AST_Conditional
  def(AST_New, return_false);
  def(AST_Sequence
  def(AST_SymbolRef
  def(AST_UnaryPrefix
  node.DEFMETHOD("is_boolean", func);

  def(AST_Node, return_false);
  def(AST_Assign
  def(AST_Binary
  def(AST_Call
  def(AST_Conditional
  def(AST_New, return_false);
  def(AST_Number, return_true);
  def(AST_Sequence
  def(AST_SymbolRef
  def(AST_Unary
  node.DEFMETHOD("is_number", func);

  def(AST_Node, return_false);
  def(AST_Assign
  def(AST_Binary
  def(AST_Call
  def(AST_Conditional
  def(AST_Sequence
  def(AST_String, return_true);
  def(AST_SymbolRef
  def(AST_UnaryPrefix
  node.DEFMETHOD("is_string", func);

  AST_Toplevel.DEFMETHOD("resolve_defines"

  def(AST_Node, noop);
  def(AST_Dot
  def(AST_SymbolDeclaration
  def(AST_SymbolRef
  node.DEFMETHOD("_find_defs", func);

  def(AST_Node
  def(AST_Statement
  def(AST_Function
  def(AST_UnaryPrefix
  def(AST_Sequence
  def(AST_Conditional
  def(AST_Binary
  node.DEFMETHOD("negate"

AST_Call.DEFMETHOD("is_expr_pure"

AST_Node.DEFMETHOD("is_call_pure", return_false);

AST_Call.DEFMETHOD("is_call_pure"

def(AST_Node, return_true);
def(AST_Array
def(AST_Assign, return_true);
def(AST_Binary
def(AST_Block
def(AST_Call
def(AST_Case
def(AST_Conditional
def(AST_Constant, return_false);
def(AST_Definitions
def(AST_Dot
def(AST_EmptyStatement, return_false);
def(AST_If
def(AST_LabeledStatement
def(AST_Lambda, return_false);
def(AST_Object
def(AST_ObjectProperty
def(AST_Sub
def(AST_Sequence
def(AST_SimpleStatement
def(AST_Switch
def(AST_SymbolDeclaration, return_false);
def(AST_SymbolRef
def(AST_This, return_false);
def(AST_Try
def(AST_Unary
def(AST_VarDef
node.DEFMETHOD("has_side_effects", func);

def(AST_Node, return_true);
def(AST_Constant, return_false);
def(AST_EmptyStatement, return_false);
def(AST_Lambda, return_false);
def(AST_SymbolDeclaration, return_false);
def(AST_This, return_false);
def(AST_Array
def(AST_Assign
def(AST_Binary
def(AST_Block
def(AST_Call
def(AST_Case
def(AST_Conditional
def(AST_Definitions
def(AST_Dot
def(AST_If
def(AST_LabeledStatement
def(AST_Object
def(AST_ObjectProperty
def(AST_Return
def(AST_Sequence
def(AST_SimpleStatement
def(AST_Sub
def(AST_Switch
def(AST_SymbolRef
def(AST_Try
def(AST_Unary
def(AST_VarDef
node.DEFMETHOD("may_throw", func);

def(AST_Node, return_false);
def(AST_Array
def(AST_Binary
def(AST_Constant, return_true);
def(AST_Lambda
def(AST_Object
def(AST_ObjectProperty
def(AST_Unary
node.DEFMETHOD("is_constant_expression", func);

def(AST_Statement, return_null);
def(AST_Jump, return_this);
def(AST_BlockStatement, block_aborts);
def(AST_SwitchBranch, block_aborts);
def(AST_If
node.DEFMETHOD("aborts", func);

AST_Scope.DEFMETHOD("hoist_declarations"
AST_Scope.DEFMETHOD("var_names"
AST_Scope.DEFMETHOD("make_var_name"
AST_Scope.DEFMETHOD("hoist_properties"
AST_Definitions.DEFMETHOD("remove_initializers"
AST_Definitions.DEFMETHOD("to_assignments"
AST_Call.DEFMETHOD("lift_sequences"
AST_Unary.DEFMETHOD("lift_sequences"
AST_Binary.DEFMETHOD("lift_sequences"
AST_Scope.DEFMETHOD("contains_this"
AST_PropAccess.DEFMETHOD("flatten_object"
